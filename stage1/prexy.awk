#!/usr/bin/env -S awk -f

BEGIN {
    IDLE = 0
    COLLECT = 1

    state = IDLE
}

FNR==1 {
    fname = FILENAME
    sub(".*/", "", fname)  # remove Unix-style path
    sub(".*\\\\", "", fname)  # remove Windows-style path

    fname_ident = fname
    sub("\\.[^.]*$", "", fname_ident)  # remove extension
    gsub(/[^[:alnum:]]+/, "_", fname_ident)
    sub(/^_+/, "", fname_ident)
    sub(/_+$/, "", fname_ident)
    fname_ident = toupper(fname_ident)
    print "#ifndef PREXY_CLIENT_" fname_ident "_H_"
    print "#define PREXY_CLIENT_" fname_ident "_H_"
    print ""
    print "/* Generated by prexy from: " fname " */"
    print ""
    print "#include \"prexy.h\""
    print ""
}

END {
    print "#endif"
}

/^prexy\s/ {
    if (state != IDLE) {
        print "// " $0
        error("Unexpected 'prexy' while parsing other structure")
    }
    state = COLLECT
    code = ""
}
state == COLLECT {
    print "// " $0
    gsub(/\/\/.*$/, "", $0) # Remove comments
    code = code $0
}
state == COLLECT && /};/ {
    state = IDLE

    code = strip(code)

    split("", data)  # clear data array

    if (parse_enum(code, data)) {
        print_enum(data)
    } else if (parse_struct(code, data)) {
        print_struct(data)
        print_struct_fieldtypes(data)
    } else {
        error("Unknown structure type")
    }

    print ""
}

function parse_enum(code, data) {
    if (!match(code, /^prexy enum ([[:alnum:]_]+)[[:space:]]*{(.*)};$/, m)) {
        return 0
    }

    data["name"] = m[1]

    count = 0
    split(m[2], variants, ",")
    for (i in variants) {
        if (match(strip(variants[i]), /^([[:alnum:]_]+)/, m)) {
            data["variants"][count++] = m[1]
        }
    }

    data["count"] = count

    return 1
}

function print_enum(data) {
    print "#define " data["name"] "_COUNT " data["count"]
    print "#define " data["name"] "_X(X) \\"
    for (i = 0; i < data["count"]; ++i) {
        print "X(" data["variants"][i] ") \\"
    }
    print ""
}

function parse_struct(code, data) {
    if (!match(code, /^prexy struct ([[:alnum:]_]+)[[:space:]]*{(.*)};$/, m)) {
        print code
        return 0
    }

    data["name"] = m[1]

    # Clear arrays
    split("", data["attrs"])
    split("", data["fields"])
    split("", attr_exists)

    field_count = 0
    attr_count = 1  # attr 0 is implicit "no-attributes" attr

    split(m[2], fields, ";")
    for (i in fields) {
        s = strip(fields[i])

        data["fields"][field_count]["length"] = 0

        if (match(s, /^px_tag\([[:space:]]*([[:alnum:]_]+)[[:space:]]*\)$/, m)) {
            # tag (0-dimensional attribute)
            if (!attr_exists[m[1]]) {
                attr_exists[m[1]] = 1
                data["attrs"][attr_count] = m[1]
                ++attr_count
            }
            data["fields"][field_count]["tags"][m[1]] = 1
        } else if (match(s, /^px_attr\([[:space:]]*([[:alnum:]_]+),[[:space:]]+(.*)\)$/, m)) {
            # attribute
            if (!attr_exists[m[1]]) {
                attr_exists[m[1]] = 1
                data["attrs"][attr_count] = m[1]
                ++attr_count
            }
            data["fields"][field_count]["attrs"][m[1]] = m[2]
        } else if (match(s, /^(enum|struct)[[:space:]]+([[:alnum:]_]+)[[:space:]+]([[:alnum:]_]+)\[[[:space:]]*([[:alnum:]]+)[[:space:]]*\]$/, m)) {
            # array of enums or structs
            data["fields"][field_count]["metatype"] = m[1] "_array"
            data["fields"][field_count]["type"] = strip(m[2])
            data["fields"][field_count]["name"] = strip(m[3])
            data["fields"][field_count]["length"] = strip(m[4])
            ++field_count
        } else if (match(s, /^(enum|struct)[[:space:]]+([[:alnum:]_]+)[[:space:]+]([[:alnum:]_]+)$/, m)) {
            # enum or struct
            data["fields"][field_count]["metatype"] = m[1]
            data["fields"][field_count]["type"] = strip(m[2])
            data["fields"][field_count]["name"] = strip(m[3])
            ++field_count
        } else if (match(s, /^([[:alnum:]_*[:space:]]+[[:space:]*])([[:alnum:]_]+)\[[[:space:]]*([[:alnum:]]+)[[:space:]]*\]$/, m)) {
            # array of simple types
            data["fields"][field_count]["metatype"] = "simple_array"
            data["fields"][field_count]["type"] = strip(m[1])
            data["fields"][field_count]["name"] = strip(m[2])
            data["fields"][field_count]["length"] = strip(m[3])
            ++field_count
        } else if (match(s, /^([[:alnum:]_*[:space:]]+[[:space:]*])([[:alnum:]_]+)$/, m)) {
            # simple type
            data["fields"][field_count]["metatype"] = "simple"
            data["fields"][field_count]["type"] = strip(m[1])
            data["fields"][field_count]["name"] = strip(m[2])
            ++field_count
        }
    }

    data["field_count"] = field_count
    data["attr_count"] = attr_count

    return 1
}

function print_struct(data) {
    for (i = 0; i < data["attr_count"]; ++i) {
        attr_name = data["attrs"][i]

        if (i == 0) {
            # attr 0 is implicit "no-attributes" attr
            print "#define " data["name"] "_X(F) \\"
        } else {
            print "#define " data["name"] "_X_" attr_name "(F) \\"
        }

        for (j = 0; j < data["field_count"]; ++j) {
            field_attr = data["fields"][j]["attrs"][attr_name]
            field_tag = data["fields"][j]["tags"][attr_name]
            printf "F("

            # attribute/tag name or metatype
            if (field_attr != "" || field_tag != "") {
                printf attr_name
            } else {
                printf data["fields"][j]["metatype"]
            }

            # type and field name
            printf ", " data["fields"][j]["type"] ", " data["fields"][j]["name"]

            # array length
            if (data["fields"][j]["length"]) {
                printf ", " data["fields"][j]["length"]
            }

            # attribute struct fields
            if (field_attr != "") {
                printf ", " data["fields"][j]["attrs"][attr_name]
            }

            print ") \\"
        }
        print ""
    }
}

function print_struct_fieldtypes(data) {
    for (i = 0; i < data["field_count"]; ++i) {
        subtype = data["fields"][i]["type"]
        metatype = data["fields"][i]["metatype"]
        name = data["fields"][i]["name"]

        # TODO: Treat arrays differently from pointers

        switch (metatype) {
        case "simple":
            fieldtype = subtype
            break
        case "simple_array":
            fieldtype = subtype "*"
            break
        case "struct":
            fieldtype = "struct " subtype
            break
        case "struct_array":
            fieldtype = "struct " subtype "*"
            break
        case "enum":
            fieldtype = "enum " subtype
            break
        case "enum_array":
            fieldtype = "enum " subtype "*"
            break
        default:
            error("print_struct_fieldtypes: Unhandled metatype " metatype)
            break
        }

        is_mut_ptr = 0
        is_const_ptr = 0
        ptr_type = 0
        if (metatype == "simple") {
            if (match(subtype, /^(.*)[[:space:]]const[[:space:]]*\*$/, m)) {
                is_const_ptr = 1
                ptr_type = strip(m[1])
            } else if (match(subtype, /^(.*)\*$/, m)) {
                is_mut_ptr = 1
                ptr_type = strip(m[1])
            }
        }

        print "#define " data["name"] "_FIELDTYPE_" name " " fieldtype
        print "#define " data["name"] "_IS_MUT_PTR_" name " " is_mut_ptr
        print "#define " data["name"] "_IS_CONST_PTR_" name " " is_const_ptr
        if (ptr_type) {
            print "#define " data["name"] "_PTRTYPE_" name " " ptr_type
        }
    }
    print ""
}

function error(msg) {
    print "error: " msg > "/dev/stderr"
    print "#error \"prexy: " msg "\""
    exit 1
}

function strip(s) {
    gsub(/^[[:space:]]+/, "", s)
    gsub(/[[:space:]]+$/, "", s)
    return s
}

