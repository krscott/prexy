#!/usr/bin/env -S awk -f

BEGIN {
    IDLE = 0
    COLLECT = 1

    state = IDLE
}

FNR==1 {
    fname = FILENAME
    sub(".*/", "", fname)  # remove Unix-style path
    sub(".*\\\\", "", fname)  # remove Windows-style path

    fname_ident = fname
    sub("\\.[^.]*$", "", fname_ident)  # remove extension
    gsub(/[^[:alnum:]]+/, "_", fname_ident)
    sub(/^_+/, "", fname_ident)
    sub(/_+$/, "", fname_ident)
    fname_ident = toupper(fname_ident)
    print "#ifndef PREXY_" fname_ident "_H_"
    print "#define PREXY_" fname_ident "_H_"
    print ""
    print "/* Generated by prexy from: " fname " */"
    print ""
}

END {
    print "#endif"
}

/^prexy\s/ {
    if (state != IDLE) {
        print "// " $0
        error("Unexpected 'prexy' while parsing other structure")
    }
    state = COLLECT
    code = ""
}
state == COLLECT {
    print "// " $0
    gsub(/\/\/.*$/, "", $0) # Remove comments
    code = code $0
}
state == COLLECT && /};/ {
    state = IDLE

    code = strip(code)

    split("", data)
    if (parse_enum(code, data)) {
        print "#define " data["name"] "_x_count " data["count"]
        print "#define " data["name"] "_x_variants(X) \\"
        for (i = 0; i < data["count"]; ++i) {
            print "X(" data["variants"][i] ") \\"
        }
    } else if (parse_struct(code, data)) {
        print "#define " data["name"] "_x_fields(F) \\"
        for (i = 0; i < data["count"]; ++i) {
            printf "F("
            printf data["fields"][i]["metatype"] ", " data["fields"][i]["type"] ", " data["fields"][i]["name"]
            if (data["fields"][i]["length"]) {
                printf ", " data["fields"][i]["length"]
            }
            print ") \\"
        }
    } else {
        error("Unknown structure type")
    }

    print ""
    print ""
}

function parse_enum(code, data) {
    if (!match(code, /^prexy enum ([[:alnum:]_]+)[[:space:]]*{(.*)};$/, m)) {
        return 0
    }

    data["name"] = m[1]

    count = 0
    split(m[2], variants, ",")
    for (i in variants) {
        if (match(strip(variants[i]), /^([[:alnum:]_]+)/, m)) {
            data["variants"][count++] = m[1]
        }
    }

    data["count"] = count

    return 1
}

function parse_struct(code, data) {
    if (!match(code, /^prexy struct ([[:alnum:]_]+)[[:space:]]*{(.*)};$/, m)) {
        print code
        return 0
    }

    data["name"] = m[1]

    count = 0
    split(m[2], fields, ";")
    for (i in fields) {
        s = strip(fields[i])

        data["fields"][count]["length"] = 0

        if (match(s, /^(enum|struct)[[:space:]]+([[:alnum:]_]+)[[:space:]+]([[:alnum:]_]+)\[[[:space:]]*([[:alnum:]]+)[[:space:]]*\]$/, m)) {
            data["fields"][count]["metatype"] = m[1] "_array"
            data["fields"][count]["type"] = strip(m[2])
            data["fields"][count]["name"] = strip(m[3])
            data["fields"][count]["length"] = strip(m[4])
            ++count
        } else if (match(s, /^(enum|struct)[[:space:]]+([[:alnum:]_]+)[[:space:]+]([[:alnum:]_]+)$/, m)) {
            data["fields"][count]["metatype"] = m[1]
            data["fields"][count]["type"] = strip(m[2])
            data["fields"][count]["name"] = strip(m[3])
            ++count
        } else if (match(s, /^([[:alnum:]_*[:space:]]+[[:space:]*])([[:alnum:]_]+)\[[[:space:]]*([[:alnum:]]+)[[:space:]]*\]$/, m)) {
            data["fields"][count]["metatype"] = "simple_array"
            data["fields"][count]["type"] = strip(m[1])
            data["fields"][count]["name"] = strip(m[2])
            data["fields"][count]["length"] = strip(m[3])
            ++count
        } else if (match(s, /^([[:alnum:]_*[:space:]]+[[:space:]*])([[:alnum:]_]+)$/, m)) {
            data["fields"][count]["metatype"] = "simple"
            data["fields"][count]["type"] = strip(m[1])
            data["fields"][count]["name"] = strip(m[2])
            ++count
        }
    }

    data["count"] = count

    return 1
}

function error(msg) {
    print "error: " msg > "/dev/stderr"
    print "#error \"prexy: " msg "\""
    exit 1
}

function strip(s) {
    gsub(/^[[:space:]]+/, "", s)
    gsub(/[[:space:]]+$/, "", s)
    return s
}

