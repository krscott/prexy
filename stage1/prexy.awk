#!/usr/bin/env -S awk -f

BEGIN {
    IDLE = 0
    COLLECT = 1

    state = IDLE
}

FNR==1 {
    fname = FILENAME
    sub(".*/", "", fname)  # remove Unix-style path
    sub(".*\\\\", "", fname)  # remove Windows-style path

    fname_ident = fname
    sub("\\.[^.]*$", "", fname_ident)  # remove extension
    gsub(/[^[:alnum:]]+/, "_", fname_ident)
    sub(/^_+/, "", fname_ident)
    sub(/_+$/, "", fname_ident)
    fname_ident = toupper(fname_ident)
    print "#ifndef PREXY_CLIENT_" fname_ident "_H_"
    print "#define PREXY_CLIENT_" fname_ident "_H_"
    print ""
    print "/* Generated by prexy from: " fname " */"
    print ""
    print "#include \"prexy.h\""
    print ""
}

END {
    print "#endif"
}

/^prexy\s/ {
    if (state != IDLE) {
        print "// " $0
        error("Unexpected 'prexy' while parsing other structure")
    }
    state = COLLECT
    code = ""
}
state == COLLECT {
    print "// " $0
    gsub(/\/\/.*$/, "", $0) # Remove comments
    code = code $0
}
state == COLLECT && /};/ {
    state = IDLE

    code = strip(code)

    split("", data)
    if (parse_enum(code, data)) {
        print "#define " data["name"] "_x_count " data["count"]
        print "#define " data["name"] "_x_variants(X) \\"
        for (i = 0; i < data["count"]; ++i) {
            print "X(" data["variants"][i] ") \\"
        }
        print ""
    } else if (parse_struct(code, data)) {
        for (i = 0; i < data["attr_count"]; ++i) {
            attr_name = data["attrs"][i]

            if (i == 0) {
                print "#define " data["name"] "_x_fields(F) \\"
            } else {
                print "#define " data["name"] "_x_fields_" attr_name "(F) \\"
            }

            for (j = 0; j < data["field_count"]; ++j) {
                field_attr = data["fields"][j]["attrs"][attr_name]
                printf "F("
                if (field_attr != "") {
                    printf attr_name
                } else {
                    printf data["fields"][j]["metatype"]
                }
                printf ", " data["fields"][j]["type"] ", " data["fields"][j]["name"]
                if (data["fields"][j]["length"]) {
                    printf ", " data["fields"][j]["length"]
                }
                if (field_attr != "") {
                    printf ", " data["fields"][j]["attrs"][attr_name]
                }
                print ") \\"
            }
            print ""
        }
    } else {
        error("Unknown structure type")
    }

    print ""
}

function parse_enum(code, data) {
    if (!match(code, /^prexy enum ([[:alnum:]_]+)[[:space:]]*{(.*)};$/, m)) {
        return 0
    }

    data["name"] = m[1]

    count = 0
    split(m[2], variants, ",")
    for (i in variants) {
        if (match(strip(variants[i]), /^([[:alnum:]_]+)/, m)) {
            data["variants"][count++] = m[1]
        }
    }

    data["count"] = count

    return 1
}

function parse_struct(code, data) {
    if (!match(code, /^prexy struct ([[:alnum:]_]+)[[:space:]]*{(.*)};$/, m)) {
        print code
        return 0
    }

    data["name"] = m[1]
    split("", data["attrs"])
    split("", data["fields"])

    field_count = 0
    attr_count = 1  # attr 0 is implicit "no-attributes" attr

    split(m[2], fields, ";")
    for (i in fields) {
        s = strip(fields[i])

        data["fields"][field_count]["length"] = 0

        if (match(s, /^px_attr\([[:space:]]*([[:alnum:]_]+),[[:space:]]+(.*)\)$/, m)) {
            data["attrs"][attr_count++] = m[1]
            data["fields"][field_count]["attrs"][m[1]] = m[2]
        } else if (match(s, /^(enum|struct)[[:space:]]+([[:alnum:]_]+)[[:space:]+]([[:alnum:]_]+)\[[[:space:]]*([[:alnum:]]+)[[:space:]]*\]$/, m)) {
            data["fields"][field_count]["metatype"] = m[1] "_array"
            data["fields"][field_count]["type"] = strip(m[2])
            data["fields"][field_count]["name"] = strip(m[3])
            data["fields"][field_count]["length"] = strip(m[4])
            ++field_count
        } else if (match(s, /^(enum|struct)[[:space:]]+([[:alnum:]_]+)[[:space:]+]([[:alnum:]_]+)$/, m)) {
            data["fields"][field_count]["metatype"] = m[1]
            data["fields"][field_count]["type"] = strip(m[2])
            data["fields"][field_count]["name"] = strip(m[3])
            ++field_count
        } else if (match(s, /^([[:alnum:]_*[:space:]]+[[:space:]*])([[:alnum:]_]+)\[[[:space:]]*([[:alnum:]]+)[[:space:]]*\]$/, m)) {
            data["fields"][field_count]["metatype"] = "simple_array"
            data["fields"][field_count]["type"] = strip(m[1])
            data["fields"][field_count]["name"] = strip(m[2])
            data["fields"][field_count]["length"] = strip(m[3])
            ++field_count
        } else if (match(s, /^([[:alnum:]_*[:space:]]+[[:space:]*])([[:alnum:]_]+)$/, m)) {
            data["fields"][field_count]["metatype"] = "simple"
            data["fields"][field_count]["type"] = strip(m[1])
            data["fields"][field_count]["name"] = strip(m[2])
            ++field_count
        }
    }

    data["field_count"] = field_count
    data["attr_count"] = attr_count

    return 1
}

function error(msg) {
    print "error: " msg > "/dev/stderr"
    print "#error \"prexy: " msg "\""
    exit 1
}

function strip(s) {
    gsub(/^[[:space:]]+/, "", s)
    gsub(/[[:space:]]+$/, "", s)
    return s
}

